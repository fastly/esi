use crate::opcodes::*;
use crate::vm_types::*;
use std::str;

fn parse_header(program_data: &[u8]) -> Result<(ProgramContext, Environment)> {
    let input_ptr = program_data.as_ptr();

    let magic = unsafe { read_u32(input_ptr) };
    if magic != MAGIC {
        return Err(VMError("magic doesn't match".to_string()));
    }

    // TODO: use version to modify or validate the context
    let version = unsafe { read_u32(input_ptr.add(4)) };
    let env = Environment::for_version(version)?;

    let input_ptr = program_data.as_ptr();

    let code_length: usize = unsafe { read_u64(input_ptr.add(8)) } as usize;
    let data_length: usize = unsafe { read_u64(input_ptr.add(16)) } as usize;
    let request_count: usize = unsafe { read_u32(input_ptr.add(24)) } as usize;
    let variable_count: usize = unsafe { read_u32(input_ptr.add(28)) } as usize;

    // TODO: Validate possible signature at offset 32, offsets after this should become dynamic

    let code_start: usize = 33;
    let data_start: usize = code_start + code_length as usize;

    let code_ptr = program_data[code_start..data_start].as_ptr();
    let data = &program_data[data_start..data_start + data_length];

    let ctx = ProgramContext {
        program_data,
        variable_count,
        request_count,
        code_length,
        code_ptr,
        data,
    };

    Ok((ctx, env))
}

fn run(ctx: ProgramContext, _env: Environment) -> Result<()> {
    let mut state = ExecutionState {
        ip: 0,
        stack: Vec::new(), // TODO: bleh
        variables: vec![Value::Null; ctx.variable_count],
    };

    while state.ip < ctx.code_length {
        //println!("ctx: {:?}", ctx);
        //println!("state: {:#?}", state);

        let opcode = unsafe { *ctx.code_ptr.add(state.ip) };
        state.ip += 1;

        //println!("opcode: {}", opcode);

        match opcode {
            // Note that the OP_NAME constants are generated by the Constraints macro on Opcode
            OP_WRITEBYTES => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let offset = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip + 4)) } as usize;
                state.ip += 8;

                println!(
                    "write bytes: {:?}",
                    str::from_utf8(&ctx.data[offset..offset + length]).unwrap()
                )
            }
            OP_WRITERESPONSE => panic!("unknown opcode: {}", opcode),
            OP_WRITEVALUE => {
                let value = state.stack.pop().unwrap();
                println!("write value: {:?}", unsafe {
                    str::from_utf8_unchecked(value.to_bytes())
                });
            }
            OP_REQUEST => panic!("unknown opcode: {}", opcode),
            OP_SUCCESS => panic!("unknown opcode: {}", opcode),
            OP_JUMP => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;

                state.ip = destination;
            }
            OP_JUMPIF => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                if state.stack.pop().unwrap().to_bool() {
                    state.ip = destination;
                }
            }
            OP_SET => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.variables[varid as usize] = state.stack.pop().unwrap();
            }
            OP_GET => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.stack.push(state.variables[varid as usize].clone());
            }
            OP_GETMETA => panic!("unknown opcode: {}", opcode),
            OP_SETKEY => panic!("unknown opcode: {}", opcode),
            OP_GETKEY => panic!("unknown opcode: {}", opcode),
            OP_GETSLICE => panic!("unknown opcode: {}", opcode),
            OP_CALL => panic!("unknown opcode: {}", opcode),
            OP_EQUALS => {
                let left = state.stack.pop().unwrap();
                let right = state.stack.pop().unwrap();
                state.stack.push(Value::Bool(left == right));
            }
            OP_NOTEQUALS => panic!("unknown opcode: {}", opcode),
            OP_LESSTHAN => panic!("unknown opcode: {}", opcode),
            OP_LESSTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHAN => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_NOT => panic!("unknown opcode: {}", opcode),
            OP_AND => panic!("unknown opcode: {}", opcode),
            OP_OR => panic!("unknown opcode: {}", opcode),
            OP_HAS => panic!("unknown opcode: {}", opcode),
            OP_HASINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_MATCHES => panic!("unknown opcode: {}", opcode),
            OP_MATCHESINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_ADD => panic!("unknown opcode: {}", opcode),
            OP_SUBTRACT => panic!("unknown opcode: {}", opcode),
            OP_MULTIPLY => panic!("unknown opcode: {}", opcode),
            OP_DIVIDE => panic!("unknown opcode: {}", opcode),
            OP_MODULO => panic!("unknown opcode: {}", opcode),
            OP_LITERALINT => panic!("unknown opcode: {}", opcode),
            OP_LITERALSTRING => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let lit_str = Value::LiteralString(unsafe { ctx.code_ptr.add(state.ip) });
                state.stack.push(lit_str);

                state.ip += 4;

                if state.ip + length > ctx.code_length {
                    break;
                }

                state.ip += length;
            }
            OP_EXIT => break,
            _ => panic!("unknown opcode"),
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::generate;
    use crate::new_parse::parse_document;

    #[test]
    fn test_vm_run() {
        let input = r#"
hello
<esi:text> world</esi:text>
<esi:assign name="foo" value="'foo'">
<esi:assign name="bar" value="$(foo)">
<esi:assign name="baz" value="$(bar)">
<esi:vars>
$(baz)
</esi:vars>
<esi:choose>
<esi:when test="$(foo) == 'nope'">
not me
</esi:when>
<esi:otherwise>
found me!
</esi:otherwise>
</esi:choose>
"#;
        let ast = parse_document(input).unwrap();
        println!("{:?}", ast);
        let program = generate(ast);
        println!("{}", program);
        let buf = program.serialize();

        let (ctx, env) = parse_header(&buf).unwrap();
        run(ctx, env).unwrap();
    }
}
