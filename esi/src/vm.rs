use crate::opcodes::*;
use crate::vm_types::*;
use std::str;

fn parse_header(program_data: &[u8]) -> Result<(ProgramContext, Environment)> {
    let input_ptr = program_data.as_ptr();

    let magic = unsafe { read_u32(input_ptr) };
    if magic != MAGIC {
        return Err(VMError("magic doesn't match".to_string()));
    }

    // TODO: use version to modify or validate the context
    let version = unsafe { read_u32(input_ptr.add(4)) };
    let env = Environment::for_version(version)?;

    let input_ptr = program_data.as_ptr();

    let code_length: usize = unsafe { read_u64(input_ptr.add(8)) } as usize;
    let data_length: usize = unsafe { read_u64(input_ptr.add(16)) } as usize;
    let request_count: usize = unsafe { read_u32(input_ptr.add(24)) } as usize;
    let variable_count: usize = unsafe { read_u32(input_ptr.add(28)) } as usize;

    // TODO: Validate possible signature at offset 32, offsets after this should become dynamic

    let code_start: usize = 33;
    let data_start: usize = code_start + code_length as usize;

    let code_ptr = program_data[code_start..data_start].as_ptr();
    let data = &program_data[data_start..data_start + data_length];

    let ctx = ProgramContext {
        program_data,
        variable_count,
        request_count,
        code_length,
        code_ptr,
        data,
    };

    Ok((ctx, env))
}

fn run<T: EnvironmentApi>(ctx: ProgramContext, _env: Environment, api: T) -> Result<()> {
    let mut state = ExecutionState::new(&ctx);

    while state.ip < ctx.code_length {
        //println!("ctx: {:?}", ctx);
        //println!("state: {:#?}", state);

        let opcode = unsafe { *ctx.code_ptr.add(state.ip) };
        state.ip += 1;

        //println!("opcode: {}", opcode);

        match opcode {
            // Note that the OP_NAME constants are generated by the Constraints macro on Opcode
            OP_WRITEBYTES => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let offset = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip + 4)) } as usize;
                state.ip += 8;

                api.write_bytes(&ctx.data[offset..offset + length]);
            }
            OP_WRITERESPONSE => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let req_handle = state.requests[reqid];
                let response = api.get_response(req_handle);
                api.write_response(&response);
            }
            OP_WRITEVALUE => {
                let value = state.stack.pop().unwrap();
                api.write_bytes(value.to_bytes());
            }
            OP_REQUEST => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let url = state.stack.pop().unwrap();
                let req_handle = api.request(url.to_bytes());
                state.requests[reqid] = req_handle;
            }
            OP_SUCCESS => {
                if state.ip + 2 > ctx.code_length {
                    break;
                }
                let reqid_count = unsafe { read_u16(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 2;

                let mut got_failure = false;
                for _ in 0..reqid_count {
                    let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                    state.ip += 4;

                    if !got_failure {
                        let req_handle = state.requests[reqid];
                        if api.get_response(req_handle) == Response::Failure {
                            got_failure = true;
                        }
                    }
                }

                state.stack.push(Value::Bool(!got_failure));
            }
            OP_JUMP => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;

                state.ip = destination;
            }
            OP_JUMPIF => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                if state.stack.pop().unwrap().to_bool() {
                    state.ip = destination;
                }
            }
            OP_SET => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.variables[varid as usize] = state.stack.pop().unwrap();
            }
            OP_GET => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.stack.push(state.variables[varid as usize].clone());
            }
            OP_GETMETA => panic!("unknown opcode: {}", opcode),
            OP_SETKEY => panic!("unknown opcode: {}", opcode),
            OP_GETKEY => panic!("unknown opcode: {}", opcode),
            OP_GETSLICE => panic!("unknown opcode: {}", opcode),
            OP_CALL => panic!("unknown opcode: {}", opcode),
            OP_EQUALS => {
                let left = state.stack.pop().unwrap();
                let right = state.stack.pop().unwrap();
                state.stack.push(Value::Bool(left == right));
            }
            OP_NOTEQUALS => {
                let left = state.stack.pop().unwrap();
                let right = state.stack.pop().unwrap();
                state.stack.push(Value::Bool(left != right));
            }
            OP_LESSTHAN => panic!("unknown opcode: {}", opcode),
            OP_LESSTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHAN => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_NOT => panic!("unknown opcode: {}", opcode),
            OP_AND => panic!("unknown opcode: {}", opcode),
            OP_OR => panic!("unknown opcode: {}", opcode),
            OP_HAS => panic!("unknown opcode: {}", opcode),
            OP_HASINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_MATCHES => panic!("unknown opcode: {}", opcode),
            OP_MATCHESINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_ADD => {
                let right = state.stack.pop().unwrap();
                let left = state.stack.pop().unwrap();
                let value = left.add(right);
                state.stack.push(value);
            }
            OP_SUBTRACT => panic!("unknown opcode: {}", opcode),
            OP_MULTIPLY => panic!("unknown opcode: {}", opcode),
            OP_DIVIDE => panic!("unknown opcode: {}", opcode),
            OP_MODULO => panic!("unknown opcode: {}", opcode),
            OP_LITERALINT => panic!("unknown opcode: {}", opcode),
            OP_LITERALSTRING => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let lit_str = Value::LiteralString(unsafe { ctx.code_ptr.add(state.ip) });
                state.stack.push(lit_str);

                state.ip += 4;

                if state.ip + length > ctx.code_length {
                    break;
                }

                state.ip += length;
            }
            OP_EXIT => break,
            _ => panic!("unknown opcode"),
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::generate;
    use crate::new_parse::parse_document;

    struct TestApi {}
    impl<'a> EnvironmentApi for &'a TestApi {
        fn request(&self, url: &[u8]) -> RequestHandle {
            println!("request: {:?}", str::from_utf8(url).unwrap());
            1
        }

        fn get_response(&self, handle: RequestHandle) -> Response {
            Response::Success
        }

        fn write_bytes(&self, data: &[u8]) {
            println!("write_bytes: {:?}", str::from_utf8(data).unwrap());
        }

        fn write_response(&self, response: &Response) {
            println!("write_response: {:?}", response);
        }
    }

    #[test]
    fn test_vm_run() {
        let input = r#"
hello
<esi:text> world</esi:text>
<esi:assign name="foo" value="'foo'">
<esi:assign name="bar" value="$(foo)">
<esi:assign name="baz" value="$(bar)">
<esi:vars>
$(baz)
</esi:vars>
<esi:choose>
<esi:when test="$(foo) == 'nope'">
not me
</esi:when>
<esi:otherwise>
found me!
</esi:otherwise>
</esi:choose>
<esi:include src="/a$(foo)b">
<esi:try>
<esi:attempt>
<esi:include src="/a">
</esi:attempt>
<esi:except>
except!
</esi:except>
</esi:try>
"#;
        let ast = parse_document(input).unwrap();
        println!("{:?}", ast);
        let program = generate(ast);
        println!("{}", program);
        let buf = program.serialize();

        let (ctx, env) = parse_header(&buf).unwrap();

        let test_api = TestApi {};
        run(ctx, env, &test_api).unwrap();
    }
}
