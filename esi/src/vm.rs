use crate::opcodes::*;
use crate::vm_types::*;
use std::str;

fn parse_header(program_data: &[u8]) -> Result<(ProgramContext, Environment)> {
    let input_ptr = program_data.as_ptr();

    let magic = unsafe { read_u32(input_ptr) };
    if magic != MAGIC {
        return Err(VMError("magic doesn't match".to_string()));
    }

    // TODO: use version to modify or validate the context
    let version = unsafe { read_u32(input_ptr.add(4)) };
    let env = Environment::for_version(version)?;

    let input_ptr = program_data.as_ptr();

    let code_length: usize = unsafe { read_u64(input_ptr.add(8)) } as usize;
    let data_length: usize = unsafe { read_u64(input_ptr.add(16)) } as usize;
    let request_count: usize = unsafe { read_u32(input_ptr.add(24)) } as usize;
    let variable_count: usize = unsafe { read_u32(input_ptr.add(28)) } as usize;

    // TODO: Validate possible signature at offset 32, offsets after this should become dynamic

    let code_start: usize = 33;
    let data_start: usize = code_start + code_length as usize;

    let code_ptr = program_data[code_start..data_start].as_ptr();
    let data = &program_data[data_start..data_start + data_length];

    let ctx = ProgramContext {
        program_data,
        variable_count,
        request_count,
        code_length,
        code_ptr,
        data,
    };

    Ok((ctx, env))
}

fn run<T: EnvironmentApi>(ctx: ProgramContext, _env: Environment, mut api: T) -> Result<()> {
    let mut state = ExecutionState::new(&ctx);

    while state.ip < ctx.code_length {
        //println!("ctx: {:?}", ctx);
        //println!("state: {:#?}", state);

        let opcode = unsafe { *ctx.code_ptr.add(state.ip) };
        state.ip += 1;

        //println!("opcode: {}", opcode);

        match opcode {
            // Note that the OP_NAME constants are generated by the Constraints macro on Opcode
            OP_WRITEBYTES => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let offset = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip + 4)) } as usize;
                state.ip += 8;

                api.write_bytes(&ctx.data[offset..offset + length]);
            }
            OP_WRITERESPONSE => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let req_handle = state.requests[reqid];
                let response = api.get_response(req_handle);
                api.write_response(&response);
            }
            OP_WRITEVALUE => {
                let value = state.stack.pop().unwrap();
                api.write_bytes(&value.to_bytes());
            }
            OP_REQUEST => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let url = state.stack.pop().unwrap();
                let req_handle = api.request(&url.to_bytes());
                state.requests[reqid] = req_handle;
            }
            OP_SUCCESS => {
                if state.ip + 2 > ctx.code_length {
                    break;
                }
                let reqid_count = unsafe { read_u16(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 2;

                let mut got_failure = false;
                for _ in 0..reqid_count {
                    let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                    state.ip += 4;

                    if !got_failure {
                        let req_handle = state.requests[reqid];
                        if api.get_response(req_handle) == Response::Failure {
                            got_failure = true;
                        }
                    }
                }

                state.stack.push(Value::Bool(!got_failure));
            }
            OP_JUMP => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                // NOTE: don't need to increment ip here after read, because we're jumping

                state.ip = destination;
            }
            OP_JUMPIF => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                if state.stack.pop().unwrap().to_bool() {
                    state.ip = destination;
                }
            }
            OP_SET => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.variables[varid as usize] = state.stack.pop().unwrap();
            }
            OP_GET => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.stack.push(state.variables[varid as usize].clone());
            }
            OP_GETMETA => panic!("unknown opcode: {}", opcode),
            OP_SETKEY => panic!("unknown opcode: {}", opcode),
            OP_GETKEY => panic!("unknown opcode: {}", opcode),
            OP_GETSLICE => panic!("unknown opcode: {}", opcode),
            OP_CALL => panic!("unknown opcode: {}", opcode),
            OP_EQUALS => {
                let left = state.stack.pop().unwrap();
                let right = state.stack.pop().unwrap();
                state.stack.push(Value::Bool(left == right));
            }
            OP_NOTEQUALS => {
                let left = state.stack.pop().unwrap();
                let right = state.stack.pop().unwrap();
                state.stack.push(Value::Bool(left != right));
            }
            OP_LESSTHAN => panic!("unknown opcode: {}", opcode),
            OP_LESSTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHAN => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_NOT => panic!("unknown opcode: {}", opcode),
            OP_AND => panic!("unknown opcode: {}", opcode),
            OP_OR => panic!("unknown opcode: {}", opcode),
            OP_HAS => panic!("unknown opcode: {}", opcode),
            OP_HASINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_MATCHES => panic!("unknown opcode: {}", opcode),
            OP_MATCHESINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_ADD => {
                let right = state.stack.pop().unwrap();
                let left = state.stack.pop().unwrap();
                let value = left.add(right);
                state.stack.push(value);
            }
            OP_SUBTRACT => {
                let right = state.stack.pop().unwrap();
                let left = state.stack.pop().unwrap();
                let value = left.subtract(right);
                state.stack.push(value);
            }
            OP_MULTIPLY => {
                let right = state.stack.pop().unwrap();
                let left = state.stack.pop().unwrap();
                let value = left.multiply(right);
                state.stack.push(value);
            }
            OP_DIVIDE => {
                let right = state.stack.pop().unwrap();
                let left = state.stack.pop().unwrap();
                let value = left.divide(right);
                state.stack.push(value);
            }
            OP_MODULO => {
                let right = state.stack.pop().unwrap();
                let left = state.stack.pop().unwrap();
                let value = left.modulo(right);
                state.stack.push(value);
            }
            OP_LITERALINT => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let num = unsafe { read_i32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;
                state.stack.push(Value::Integer(num));
            }
            OP_LITERALSTRING => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let lit_str = Value::LiteralString(unsafe { ctx.code_ptr.add(state.ip) });
                state.stack.push(lit_str);

                state.ip += 4;

                if state.ip + length > ctx.code_length {
                    break;
                }

                state.ip += length;
            }
            OP_EXIT => return Ok(()),
            _ => panic!("unknown opcode"),
        }
    }

    Err(VMError("exited early!".to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::generate;
    use crate::new_parse::parse_document;
    use bytes::{BufMut, BytesMut};

    struct TestApi {
        buf: BytesMut,
    }
    impl TestApi {
        fn new() -> Self {
            Self {
                buf: BytesMut::new(),
            }
        }
    }
    impl<'a> EnvironmentApi for &'a mut TestApi {
        fn request(&self, url: &[u8]) -> RequestHandle {
            match url {
                b"/a" => 1,
                _ => panic!("unknown url"),
            }
        }

        fn get_response(&self, handle: RequestHandle) -> Response {
            Response::Success
        }

        fn write_bytes(&mut self, data: &[u8]) {
            self.buf.put(data);
        }

        fn write_response(&mut self, response: &Response) {
            self.buf.put(&format!("{:?}", response).into_bytes()[..]);
        }
    }

    #[test]
    fn test_vm_static_text() {
        let input = r#"hello<esi:text> world</esi:text>"#;
        let ast = parse_document(input).unwrap();
        let program = generate(ast);
        let buf = program.serialize();

        let (ctx, env) = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, env, &mut test_api).unwrap();

        assert_eq!(b"hello world", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_simple_variables() {
        let input = concat!(
            r#"<esi:assign name="foo" value="'foo'">"#,
            r#"<esi:assign name="bar" value="$(foo)">"#,
            r#"<esi:assign name="num" value="123">"#,
            r#"<esi:vars name="$(bar)">"#,
            r#"<esi:vars> - $(num)</esi:vars>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast);
        let buf = program.serialize();

        let (ctx, env) = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, env, &mut test_api).unwrap();

        assert_eq!(b"foo - 123", &test_api.buf[..]);
    }
    #[test]
    fn test_vm_simple_math() {
        let input = concat!(
            r#"<esi:assign name="num" value="64">"#,
            r#"<esi:assign name="add" value="$(num) + 1">"#,
            r#"<esi:assign name="sub" value="$(num) - 1">"#,
            r#"<esi:assign name="div" value="$(num) / 2">"#,
            r#"<esi:assign name="mult" value="$(num) * 2">"#,
            r#"<esi:assign name="mod" value="$(num) % 10">"#,
            r#"<esi:vars>$(add) - $(sub) - $(div) - $(mult) - $(mod)</esi:vars>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast);
        let buf = program.serialize();

        let (ctx, env) = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, env, &mut test_api).unwrap();

        assert_eq!(b"65 - 63 - 32 - 128 - 4", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_choose() {
        let input = concat!(
            r#"<esi:assign name="foo" value="'foo'">"#,
            r#"<esi:choose>"#,
            r#"<esi:when test="$(foo) == 'foo'">"#,
            r#"YES"#,
            r#"</esi:when>"#,
            r#"<esi:otherwise>"#,
            r#"NO"#,
            r#"</esi:otherwise>"#,
            r#"</esi:choose>"#,
            r#" - "#,
            r#"<esi:choose>"#,
            r#"<esi:when test="$(foo) == 'bar'">"#,
            r#"NO"#,
            r#"</esi:when>"#,
            r#"<esi:otherwise>"#,
            r#"YES"#,
            r#"</esi:otherwise>"#,
            r#"</esi:choose>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast);
        let buf = program.serialize();

        let (ctx, env) = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, env, &mut test_api).unwrap();

        assert_eq!(b"YES - YES", &test_api.buf[..]);
    }
    // <esi:include src="/a$(foo)b">
    // <esi:try>
    // <esi:attempt>
    // <esi:include src="/a">
    // </esi:attempt>
    // <esi:except>
    // except!
    // </esi:except>
    // </esi:try>
    // "#;
}
