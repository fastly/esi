use crate::abi::*;
use crate::opcodes::*;
use crate::vm_types::*;

fn parse_header(program_data: &[u8]) -> Result<ProgramContext> {
    let input_ptr = program_data.as_ptr();

    let magic = unsafe { read_u32(input_ptr) };
    if magic != MAGIC {
        return Err(VMError("magic doesn't match".to_string()));
    }

    // TODO: use version to modify or validate the context
    let abi_version = unsafe { read_u32(input_ptr.add(4)) };

    let input_ptr = program_data.as_ptr();

    let code_length: usize = unsafe { read_u64(input_ptr.add(8)) } as usize;
    let data_length: usize = unsafe { read_u64(input_ptr.add(16)) } as usize;
    let request_count: usize = unsafe { read_u32(input_ptr.add(24)) } as usize;
    let variable_count: usize = unsafe { read_u32(input_ptr.add(28)) } as usize;

    // TODO: Validate possible signature at offset 32, offsets after this should become dynamic

    let code_start: usize = 33;
    let data_start: usize = code_start + code_length as usize;

    let code_ptr = program_data[code_start..data_start].as_ptr();
    let data = &program_data[data_start..data_start + data_length];

    let ctx = ProgramContext {
        program_data,
        abi_version,
        variable_count,
        request_count,
        code_length,
        code_ptr,
        data,
    };

    Ok(ctx)
}

fn run<T: EnvironmentApi>(ctx: ProgramContext, mut api: T) -> Result<()> {
    let abi = Abi::for_version(ctx.abi_version)?;
    let mut state = ExecutionState::new(&ctx);

    while state.ip < ctx.code_length {
        //println!("ctx: {:?}", ctx);
        //println!("state: {:#?}", state);

        let opcode = unsafe { *ctx.code_ptr.add(state.ip) };
        state.ip += 1;

        //println!("opcode: {}", opcode);

        match opcode {
            // Note that the OP_NAME constants are generated by the Constraints macro on Opcode
            OP_WRITEBYTES => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let offset = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip + 4)) } as usize;
                state.ip += 8;

                api.write_bytes(&ctx.data[offset..offset + length]);
            }
            OP_WRITERESPONSE => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let req_handle = state.requests[reqid];
                let response = api.get_response(req_handle);
                api.write_response(&response);
            }
            OP_WRITEVALUE => {
                let value = state.pop_value();
                api.write_bytes(&value.to_bytes());
            }
            OP_REQUEST => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let url = state.pop_value();
                let req_handle = api.request(&url.to_bytes());
                state.requests[reqid] = req_handle;
            }
            OP_SUCCESS => {
                if state.ip + 2 > ctx.code_length {
                    break;
                }
                let reqid_count = unsafe { read_u16(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 2;

                let mut got_failure = false;
                for _ in 0..reqid_count {
                    let reqid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                    state.ip += 4;

                    if !got_failure {
                        let req_handle = state.requests[reqid];
                        if api.get_response(req_handle) == Response::Failure {
                            got_failure = true;
                        }
                    }
                }

                state.push(Value::Bool(!got_failure));
            }
            OP_JUMP => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                // NOTE: don't need to increment ip here after read, because we're jumping

                state.ip = destination;
            }
            OP_JUMPIF => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let destination = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                if state.pop_value().to_bool() {
                    state.ip = destination;
                }
            }
            OP_SET => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.variables[varid as usize] = state.pop_value();
            }
            OP_GET => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let varid = unsafe { read_u32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                state.push_ref(varid as usize);
            }
            OP_GETMETA => panic!("unknown opcode: {}", opcode),
            OP_SETKEY => {
                let value = state.pop_value();
                let subkey = state.pop_value();
                let var = state.pop();

                match var {
                    StackEntry::Ref(varid) => {
                        let var = state.variables.get_mut(varid);
                        match var {
                            Some(Value::List(ref mut list)) => match subkey {
                                Value::Integer(i) => {
                                    list[i as usize] = value;
                                }
                                _ => panic!("can't set subkey on list using a non-integer"),
                            },
                            _ => panic!("can't set subkey on non-list"),
                        }
                    }
                    _ => panic!("can't set subkey on non-ref"),
                }
            }
            OP_GETKEY => {
                let subkey = state.pop_value();
                let var = state.pop();

                let value = match var {
                    StackEntry::Ref(varid) => {
                        let var = state.variables.get(varid);
                        match var {
                            Some(Value::List(ref list)) => match subkey {
                                Value::Integer(i) => list[i as usize].clone(),
                                _ => panic!("can't get subkey on list using a non-integer"),
                            },
                            _ => panic!("can't get subkey on non-list"),
                        }
                    }
                    _ => panic!("can't get subkey on non-ref"),
                };

                state.push(value);
            }
            OP_GETSLICE => panic!("unknown opcode: {}", opcode),
            OP_CALL => {
                if state.ip + 8 > ctx.code_length {
                    break;
                }
                let func_id = unsafe { read_i32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;
                let args_len = unsafe { read_i32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;

                abi.call_function(func_id as usize, args_len as usize, &mut state);
            }
            OP_EQUALS => {
                let left = state.pop_value();
                let right = state.pop_value();
                state.push(Value::Bool(left == right));
            }
            OP_NOTEQUALS => {
                let left = state.pop_value();
                let right = state.pop_value();
                state.push(Value::Bool(left != right));
            }
            OP_LESSTHAN => panic!("unknown opcode: {}", opcode),
            OP_LESSTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHAN => panic!("unknown opcode: {}", opcode),
            OP_GREATERTHANOREQUALS => panic!("unknown opcode: {}", opcode),
            OP_NOT => panic!("unknown opcode: {}", opcode),
            OP_AND => panic!("unknown opcode: {}", opcode),
            OP_OR => panic!("unknown opcode: {}", opcode),
            OP_HAS => panic!("unknown opcode: {}", opcode),
            OP_HASINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_MATCHES => panic!("unknown opcode: {}", opcode),
            OP_MATCHESINSENSITIVE => panic!("unknown opcode: {}", opcode),
            OP_ADD => {
                let right = state.pop_value();
                let left = state.pop_value();
                let value = left.add(right);
                state.push(value);
            }
            OP_SUBTRACT => {
                let right = state.pop_value();
                let left = state.pop_value();
                let value = left.subtract(right);
                state.push(value);
            }
            OP_MULTIPLY => {
                let right = state.pop_value();
                let left = state.pop_value();
                let value = left.multiply(right);
                state.push(value);
            }
            OP_DIVIDE => {
                let right = state.pop_value();
                let left = state.pop_value();
                let value = left.divide(right);
                state.push(value);
            }
            OP_MODULO => {
                let right = state.pop_value();
                let left = state.pop_value();
                let value = left.modulo(right);
                state.push(value);
            }
            OP_LITERALINT => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let num = unsafe { read_i32(ctx.code_ptr.add(state.ip)) };
                state.ip += 4;
                state.push(Value::Integer(num));
            }
            OP_LITERALSTRING => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                let lit_str = Value::LiteralString(unsafe { ctx.code_ptr.add(state.ip) });
                state.push(lit_str);

                state.ip += 4;

                if state.ip + length > ctx.code_length {
                    break;
                }

                state.ip += length;
            }
            OP_MAKELIST => {
                if state.ip + 4 > ctx.code_length {
                    break;
                }
                let length = unsafe { read_u32(ctx.code_ptr.add(state.ip)) } as usize;
                state.ip += 4;

                let list = Value::List((0..length).map(|_| state.pop_value()).collect());
                state.push(list);
            }
            OP_EXIT => return Ok(()),
            _ => panic!("unknown opcode"),
        }
    }

    Err(VMError("exited early!".to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::generate;
    use crate::new_parse::parse_document;
    use bytes::{BufMut, BytesMut};

    struct TestApi {
        buf: BytesMut,
    }
    impl TestApi {
        fn new() -> Self {
            Self {
                buf: BytesMut::new(),
            }
        }
    }
    impl<'a> EnvironmentApi for &'a mut TestApi {
        fn request(&self, url: &[u8]) -> RequestHandle {
            match url {
                b"/a" => 1,
                _ => panic!("unknown url"),
            }
        }

        fn get_response(&self, handle: RequestHandle) -> Response {
            Response::Success
        }

        fn write_bytes(&mut self, data: &[u8]) {
            self.buf.put(data);
        }

        fn write_response(&mut self, response: &Response) {
            self.buf.put(&format!("{:?}", response).into_bytes()[..]);
        }
    }

    #[test]
    fn test_vm_static_text() {
        let input = r#"hello<esi:text> world</esi:text>"#;
        let ast = parse_document(input).unwrap();
        let program = generate(ast, &ABI_TEST);
        let buf = program.serialize();

        let ctx = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, &mut test_api).unwrap();

        assert_eq!(b"hello world", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_simple_variables() {
        let input = concat!(
            r#"<esi:assign name="foo" value="'foo'">"#,
            r#"<esi:assign name="bar" value="$(foo)">"#,
            r#"<esi:assign name="num" value="123">"#,
            r#"<esi:vars name="$(bar)">"#,
            r#"<esi:vars> - $(num)</esi:vars>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast, &ABI_TEST);
        let buf = program.serialize();

        let ctx = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, &mut test_api).unwrap();

        assert_eq!(b"foo - 123", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_list_variables() {
        let input = concat!(
            r#"<esi:assign name="colors" value="[ 'red', 'blue', 'green' ]">"#,
            r#"<esi:assign name="colors{0}" value="'purple'"/>"#,
            r#"<esi:assign name="first_color" value="$(colors{0})">"#,
            r#"<esi:vars>$(first_color) $(colors{2})</esi:vars>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast, &ABI_TEST);
        let buf = program.serialize();

        let ctx = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, &mut test_api).unwrap();

        assert_eq!(b"purple green", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_simple_math() {
        let input = concat!(
            r#"<esi:assign name="num" value="64">"#,
            r#"<esi:assign name="add" value="$(num) + 1">"#,
            r#"<esi:assign name="sub" value="$(num) - 1">"#,
            r#"<esi:assign name="div" value="$(num) / 2">"#,
            r#"<esi:assign name="mult" value="$(num) * 2">"#,
            r#"<esi:assign name="mod" value="$(num) % 10">"#,
            r#"<esi:vars>$(add) - $(sub) - $(div) - $(mult) - $(mod)</esi:vars>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast, &ABI_TEST);
        let buf = program.serialize();

        let ctx = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, &mut test_api).unwrap();

        assert_eq!(b"65 - 63 - 32 - 128 - 4", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_choose() {
        let input = concat!(
            r#"<esi:assign name="foo" value="'foo'">"#,
            r#"<esi:choose>"#,
            r#"<esi:when test="$(foo) == 'foo'">YES</esi:when>"#,
            r#"<esi:otherwise>NO</esi:otherwise>"#,
            r#"</esi:choose>"#,
            r#" - "#,
            r#"<esi:choose>"#,
            r#"<esi:when test="$(foo) == 'bar'">NO</esi:when>"#,
            r#"<esi:otherwise>YES</esi:otherwise>"#,
            r#"</esi:choose>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast, &ABI_TEST);
        let buf = program.serialize();

        let ctx = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, &mut test_api).unwrap();

        assert_eq!(b"YES - YES", &test_api.buf[..]);
    }

    #[test]
    fn test_vm_call() {
        let input = concat!(
            r#"<esi:vars>"#,
            r#"$ping()"#,
            r#" - "#,
            r#"$identity(123)"#,
            r#" - "#,
            r#"$identity('hello')"#,
            r#" - "#,
            r#"$make_list(1,2,3)"#,
            r#"</esi:vars>"#,
        );

        let ast = parse_document(input).unwrap();
        let program = generate(ast, &ABI_TEST);
        let buf = program.serialize();

        let ctx = parse_header(&buf).unwrap();
        let mut test_api = TestApi::new();
        run(ctx, &mut test_api).unwrap();

        assert_eq!(b"pong - 123 - hello - [1,2,3]", &test_api.buf[..]);
    }

    // <esi:include src="/a$(foo)b">
    // <esi:try>
    // <esi:attempt>
    // <esi:include src="/a">
    // </esi:attempt>
    // <esi:except>
    // except!
    // </esi:except>
    // </esi:try>
    // "#;
}
